---
title: "Desafio 07"
author: "Julia Folgueral - RA: 277178"
format: html
editor: visual
---

```{r}
library(RSQLite)
library(tidyverse)
if(!"discoCopy.db" %in% list.files("dico.db")){
file.copy("disco.db"
,
"discoCopy.db")
} # Modificaremos esse arquivo

```

```{r}
db <- dbConnect(SQLite(),
"discoCopy.db")
```

```{r}
# Tabelas existentes em disco.db
dbListTables(db)
```

```{r}
# A sintaxe para criar uma tabela vazia, no SQLite, é através do comando CREATE TABLE nome (col1 tipo, col2 tipo2, ...)

dbExecute(db,
"CREATE TABLE instruments
(AlbumId INTEGER,
TrackId INTEGER,
ElectricGuitar INTEGER,
Singer INTEGER,
Trumpet INTEGER)")

```

```{r}
dbListFields(db,
'instruments')
```

```{r}
# Remover a tabela "instruments"
dbExecute(db,
"DROP TABLE instruments")
```

```{r}
dbListTables(db)
```

```{r}
# Cuidado! Se Um usuário malicioso pode inserir algo como aname <- "Gilberto Gil'; DROP TABLE 'albums" e destruir o banco de dados.

aname = "Gilberto Gil" 
sql = paste0("SELECT ArtistId FROM artists "
,
"WHERE Name = '"
, aname,
"'")
aId = dbGetQuery(db, sql)
sql = paste('SELECT Title FROM albums'
,
'WHERE ArtistId ='
, aId)
dbGetQuery(db, sql)

```

```{r}
# Esse código é mais seguro que o anterior. É uma boa prática para evitar que seu banco seja apagado por um usuário.
sql = paste("SELECT ArtistId FROM artists"
,
"WHERE Name = ?")
query <- dbSendQuery(db, sql)
dbBind(query, list("Gilberto Gil"))
aId <- dbFetch(query)
dbClearResult(query)
# Segundo passo interno, não deve causar problema
sql = paste('SELECT Title FROM albums'
,
'WHERE ArtistId ='
, aId)
dbGetQuery(db, sql)
```

```{r}
# Anteriormente destruímos o objeto "instruments", então precisamos criá-lo novamente:
dbExecute(db,
"CREATE TABLE instruments
(AlbumId INTEGER,
TrackId INTEGER,
ElectricGuitar INTEGER,
Singer INTEGER,
Trumpet INTEGER)")

# 
dbListFields(db,
'instruments')
```

```{r}
# Vamos inserir uma nova informação em "instruments"
# Eu Tu Eles: AlbumId 85,
sql = paste('SELECT TrackId, Name FROM tracks'
,
'WHERE AlbumId = 85')
dbGetQuery(db, sql) %>% head
```

```{r}
# Adicionando os novos valores
dbExecute(db,
"INSERT INTO instruments
              VALUES ('85', '1075', 0, 1, 0),
              ('85','1078', 0, 1, 0); ")

```

```{r}
dbGetQuery(db, "SELECT * FROM instruments")
```

```{r}
# Inserindo a tabela "mtcars" do R no nosso banco
dbWriteTable(db, "mtcars", mtcars) 
dbListTables(db)

```

```{r}
dbGetQuery(db,
"SELECT * FROM mtcars") %>% head(3)
```

```{r}
# O parâmetro append concatena uma tabela nova a dados existentes. 
theAvgCar <- mtcars %>%
summarise_all(function(x) round(mean(x), 2))
theAvgCar
```

```{r}
dbWriteTable(db,"mtcars", theAvgCar, append = TRUE)

dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)

```

```{r}
# O parâmetro overwrite sobrescreve a tabela (use com cuidado!)
dbWriteTable(db,"mtcars", mtcars, overwrite = TRUE)

dbGetQuery(db,"SELECT * FROM mtcars") %>% tail(3)
```

```{r}
# Ler dados em chunck
res <- dbSendQuery(db,"SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
chunk <- dbFetch(res, n = 5)
print(nrow(chunk))
}

```

```{r}
# O exemplo acima só guarda o último chunck, então pode não ser muito eficiente
dbClearResult(res)
```

```{r}
# É importante encerrar suas conexões com dbDisconnect(). 
#  Além disso, vamos remover a cópia que fizemos da database disco.db
dbDisconnect(db)
if("discoCopy.db" %in% list.files("../dados/")){
file.remove("../dados/discoCopy.db")
}

```

```{r}
# Criando a minha base de dados

#install.packages("vroom")
#library(vroom)

airports <- read_csv("airports.csv", col_types = "cccccdd")
airlines <- read_csv("airlines.csv", col_types = "cc")
air <- dbConnect(SQLite(), dbname="air.db")
dbWriteTable(air, name = "airports", airports)
dbWriteTable(air, name = "airlines", airlines)
dbListTables(air)

```

```{r}
# Também podemos usar a função copy_to(conn, df) do dplyr! A sintaxe é parecida.
# Agora, vamos destruir a conexão e a tabela.
dbDisconnect(air)
if("air.db" %in% list.files("../dados/")){
file.remove("../dados/air.db")
}
```

```{r}
# O pacote dbplyr estende algumas funcionalidades do dplyr a dados que estão armazenados em um bancos de dados externo.

library(RSQLite)
library(tidyverse)
library(dbplyr)
db <- dbConnect(SQLite(), "disco.db") # original

tracks <- tbl(db, "tracks") # dplyr
tracks %>% head(3)

```


```{r}
# Verbos do dplyr
meanTracks <- tracks %>%
group_by(AlbumId) %>%
summarise(AvLen = mean(Milliseconds, na.rm = TRUE),
AvCost = mean(UnitPrice, na.rm = TRUE))
meanTracks
```

```{r}
# Comandos do SQLite
meanTracks %>% show_query()

```

```{r}
# Repare que o sumário só diz "... with more rows". Quando decidimos o que precisamos, podemos usar o comando collect().

mT <- meanTracks %>% collect()
mT
```

```{r}
# Disconectando a base de dados
dbDisconnect(db)
```

